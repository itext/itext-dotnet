/*

This file is part of the iText (R) project.
Copyright (c) 1998-2022 iText Group NV
Authors: Bruno Lowagie, Paulo Soares, et al.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License version 3
as published by the Free Software Foundation with the addition of the
following permission added to Section 15 as permitted in Section 7(a):
FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED BY
ITEXT GROUP. ITEXT GROUP DISCLAIMS THE WARRANTY OF NON INFRINGEMENT
OF THIRD PARTY RIGHTS

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Affero General Public License for more details.
You should have received a copy of the GNU Affero General Public License
along with this program; if not, see http://www.gnu.org/licenses or write to
the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA, 02110-1301 USA, or download the license from the following URL:
http://itextpdf.com/terms-of-use/

The interactive user interfaces in modified source and object code versions
of this program must display Appropriate Legal Notices, as required under
Section 5 of the GNU Affero General Public License.

In accordance with Section 7(b) of the GNU Affero General Public License,
a covered work must retain the producer line in every PDF that is created
or manipulated using iText.

You can be released from the requirements of the license by purchasing
a commercial license. Buying such a license is mandatory as soon as you
develop commercial activities involving the iText software without
disclosing the source code of your own applications.
These activities include: offering paid services to customers as an ASP,
serving PDFs on the fly in a web application, shipping iText with a closed
source product.

For more information, please contact iText Software Corp. at this
address: sales@itextpdf.com
*/
using System;
using System.Collections.Generic;
using Microsoft.Extensions.Logging;
using iText.Commons;
using iText.Commons.Utils;
using iText.Forms.Exceptions;
using iText.Forms.Fields;
using iText.Forms.Xfa;
using iText.Kernel.Exceptions;
using iText.Kernel.Geom;
using iText.Kernel.Pdf;
using iText.Kernel.Pdf.Annot;
using iText.Kernel.Pdf.Canvas;
using iText.Kernel.Pdf.Tagging;
using iText.Kernel.Pdf.Tagutils;
using iText.Kernel.Pdf.Xobject;

namespace iText.Forms {
    /// <summary>This class represents the static form technology AcroForm on a PDF file.</summary>
    public class PdfAcroForm : PdfObjectWrapper<PdfDictionary> {
        private static readonly ILogger LOGGER = ITextLogManager.GetLogger(typeof(iText.Forms.PdfAcroForm));

        /// <summary>
        /// To be used with
        /// <see cref="SetSignatureFlags(int)"/>.
        /// </summary>
        /// <remarks>
        /// To be used with
        /// <see cref="SetSignatureFlags(int)"/>.
        /// <br />
        /// <blockquote>
        /// If set, the document contains at least one signature field. This flag
        /// allows a conforming reader to enable user interface items (such as menu
        /// items or pushbuttons) related to signature processing without having to
        /// scan the entire document for the presence of signature fields.
        /// (ISO 32000-1, section 12.7.2 "Interactive Form Dictionary")
        /// </blockquote>
        /// </remarks>
        public const int SIGNATURE_EXIST = 1;

        /// <summary>
        /// To be used with
        /// <see cref="SetSignatureFlags(int)"/>.
        /// </summary>
        /// <remarks>
        /// To be used with
        /// <see cref="SetSignatureFlags(int)"/>.
        /// <br />
        /// <blockquote>
        /// If set, the document contains signatures that may be invalidated if the
        /// file is saved (written) in a way that alters its previous contents, as
        /// opposed to an incremental update. Merely updating the file by appending
        /// new information to the end of the previous version is safe. Conforming
        /// readers may use this flag to inform a user requesting a full save that
        /// signatures will be invalidated and require explicit confirmation before
        /// continuing with the operation.
        /// (ISO 32000-1, section 12.7.2 "Interactive Form Dictionary")
        /// </blockquote>
        /// </remarks>
        public const int APPEND_ONLY = 2;

        /// <summary>
        /// Keeps track of whether or not appearances must be generated by the form
        /// fields themselves, or by the PDF viewer application.
        /// </summary>
        /// <remarks>
        /// Keeps track of whether or not appearances must be generated by the form
        /// fields themselves, or by the PDF viewer application. Default is
        /// <c>true</c>.
        /// </remarks>
        protected internal bool generateAppearance = true;

        /// <summary>
        /// A map of field names and their associated
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// objects.
        /// </summary>
        protected internal IDictionary<String, PdfFormField> fields = new LinkedDictionary<String, PdfFormField>();

        /// <summary>The PdfDocument to which the PdfAcroForm belongs.</summary>
        protected internal PdfDocument document;

        private PdfDictionary defaultResources;

        private ICollection<PdfFormField> fieldsForFlattening = new LinkedHashSet<PdfFormField>();

        private XfaForm xfaForm;

        /// <summary>Creates a PdfAcroForm as a wrapper of a dictionary.</summary>
        /// <remarks>
        /// Creates a PdfAcroForm as a wrapper of a dictionary.
        /// Also initializes an XFA form if an <c>/XFA</c> entry is present in
        /// the dictionary.
        /// </remarks>
        /// <param name="pdfObject">the PdfDictionary to be wrapped</param>
        private PdfAcroForm(PdfDictionary pdfObject, PdfDocument pdfDocument)
            : base(pdfObject) {
            document = pdfDocument;
            GetFormFields();
            xfaForm = new XfaForm(pdfObject);
        }

        /// <summary>
        /// Creates a PdfAcroForm from a
        /// <see cref="iText.Kernel.Pdf.PdfArray"/>
        /// of fields.
        /// </summary>
        /// <remarks>
        /// Creates a PdfAcroForm from a
        /// <see cref="iText.Kernel.Pdf.PdfArray"/>
        /// of fields.
        /// Also initializes an empty XFA form.
        /// </remarks>
        /// <param name="fields">
        /// a
        /// <see cref="iText.Kernel.Pdf.PdfArray"/>
        /// of
        /// <see cref="iText.Kernel.Pdf.PdfDictionary"/>
        /// objects
        /// </param>
        private PdfAcroForm(PdfArray fields)
            : this(CreateAcroFormDictionaryByFields(fields), null) {
            SetForbidRelease();
        }

        /// <summary>Retrieves AcroForm from the document.</summary>
        /// <remarks>
        /// Retrieves AcroForm from the document. If there is no AcroForm in the
        /// document Catalog and createIfNotExist flag is true then the AcroForm
        /// dictionary will be created and added to the document.
        /// </remarks>
        /// <param name="document">
        /// the document to retrieve the
        /// <see cref="PdfAcroForm"/>
        /// from
        /// </param>
        /// <param name="createIfNotExist">
        /// when <c>true</c>, this method will create a
        /// <see cref="PdfAcroForm"/>
        /// if none exists for this document
        /// </param>
        /// <returns>
        /// the
        /// <see cref="iText.Kernel.Pdf.PdfDocument">document</see>
        /// 's AcroForm,
        /// or a new one provided that <c>createIfNotExist</c> parameter is <c>true</c>, otherwise <c>null</c>.
        /// </returns>
        public static iText.Forms.PdfAcroForm GetAcroForm(PdfDocument document, bool createIfNotExist) {
            PdfDictionary acroFormDictionary = document.GetCatalog().GetPdfObject().GetAsDictionary(PdfName.AcroForm);
            iText.Forms.PdfAcroForm acroForm = null;
            if (acroFormDictionary == null) {
                if (createIfNotExist) {
                    acroForm = new iText.Forms.PdfAcroForm(new PdfArray());
                    acroForm.MakeIndirect(document);
                    document.GetCatalog().Put(PdfName.AcroForm, acroForm.GetPdfObject());
                    document.GetCatalog().SetModified();
                }
            }
            else {
                acroForm = new iText.Forms.PdfAcroForm(acroFormDictionary, document);
            }
            if (acroForm != null) {
                acroForm.defaultResources = acroForm.GetDefaultResources();
                if (acroForm.defaultResources == null) {
                    acroForm.defaultResources = new PdfDictionary();
                }
                acroForm.document = document;
                acroForm.xfaForm = new XfaForm(document);
            }
            return acroForm;
        }

        /// <summary>This method adds the field to the last page in the document.</summary>
        /// <remarks>
        /// This method adds the field to the last page in the document.
        /// If there's no pages, creates a new one.
        /// </remarks>
        /// <param name="field">
        /// the
        /// <see cref="iText.Forms.Fields.PdfFormField"/>
        /// to be added to the form
        /// </param>
        public virtual void AddField(PdfFormField field) {
            PdfPage page;
            if (document.GetNumberOfPages() == 0) {
                document.AddNewPage();
            }
            page = document.GetLastPage();
            AddField(field, page);
        }

        /// <summary>This method adds the field to a specific page.</summary>
        /// <param name="field">
        /// the
        /// <see cref="iText.Forms.Fields.PdfFormField"/>
        /// to be added to the form
        /// </param>
        /// <param name="page">
        /// the
        /// <see cref="iText.Kernel.Pdf.PdfPage"/>
        /// on which to add the field
        /// </param>
        public virtual void AddField(PdfFormField field, PdfPage page) {
            PdfArray kids = field.GetKids();
            PdfDictionary fieldDic = field.GetPdfObject();
            if (kids != null) {
                ProcessKids(kids, fieldDic, page);
            }
            PdfArray fieldsArray = GetFields();
            fieldsArray.Add(fieldDic);
            fieldsArray.SetModified();
            fields.Put(field.GetFieldName().ToUnicodeString(), field);
            if (field.GetKids() != null) {
                IterateFields(field.GetKids(), fields);
            }
            if (fieldDic.ContainsKey(PdfName.Subtype) && page != null) {
                PdfAnnotation annot = PdfAnnotation.MakeAnnotation(fieldDic);
                AddWidgetAnnotationToPage(page, annot);
            }
            SetModified();
        }

        /// <summary>
        /// This method merges field with its annotation and place it on the given
        /// page.
        /// </summary>
        /// <remarks>
        /// This method merges field with its annotation and place it on the given
        /// page. This method won't work if the field has no or more than one widget
        /// annotations.
        /// </remarks>
        /// <param name="field">
        /// the
        /// <see cref="iText.Forms.Fields.PdfFormField"/>
        /// to be added to the form
        /// </param>
        /// <param name="page">
        /// the
        /// <see cref="iText.Kernel.Pdf.PdfPage"/>
        /// on which to add the field
        /// </param>
        public virtual void AddFieldAppearanceToPage(PdfFormField field, PdfPage page) {
            PdfDictionary fieldDict = field.GetPdfObject();
            PdfArray kids = field.GetKids();
            if (kids == null || kids.Size() > 1) {
                return;
            }
            PdfDictionary kidDict = (PdfDictionary)kids.Get(0);
            PdfName type = kidDict.GetAsName(PdfName.Subtype);
            if (type != null && type.Equals(PdfName.Widget)) {
                if (!kidDict.ContainsKey(PdfName.FT)) {
                    // kid is not a merged field with widget
                    MergeWidgetWithParentField(fieldDict, kidDict);
                }
                DefineWidgetPageAndAddToIt(page, fieldDict, false);
            }
        }

        /// <summary>
        /// Gets the
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// s as a
        /// <see cref="System.Collections.IDictionary{K, V}"/>.
        /// </summary>
        /// <returns>
        /// a map of field names and their associated
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// objects
        /// </returns>
        public virtual IDictionary<String, PdfFormField> GetFormFields() {
            if (fields.Count == 0) {
                fields = IterateFields(GetFields());
            }
            return fields;
        }

        /// <summary>
        /// Gets a collection of
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// s, prepared for flattening using
        /// <see cref="PartialFormFlattening(System.String)"/>
        /// method.
        /// </summary>
        /// <remarks>
        /// Gets a collection of
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// s, prepared for flattening using
        /// <see cref="PartialFormFlattening(System.String)"/>
        /// method.
        /// If returned collection is empty, all form fields will be flattened on
        /// <see cref="FlattenFields()">flattenFields</see>
        /// call.
        /// </remarks>
        /// <returns>
        /// a collection of
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// s for flattening
        /// </returns>
        public virtual ICollection<PdfFormField> GetFieldsForFlattening() {
            return JavaCollectionsUtil.UnmodifiableCollection(fieldsForFlattening);
        }

        /// <summary>
        /// Gets the
        /// <see cref="iText.Kernel.Pdf.PdfDocument"/>
        /// this
        /// <see cref="PdfAcroForm"/>
        /// belongs to.
        /// </summary>
        /// <returns>the document of this form</returns>
        public virtual PdfDocument GetPdfDocument() {
            return document;
        }

        /// <summary>Sets the <c>NeedAppearances</c> boolean property on the AcroForm.</summary>
        /// <remarks>
        /// Sets the <c>NeedAppearances</c> boolean property on the AcroForm.
        /// NeedAppearances has been deprecated in PDF 2.0.
        /// <br />
        /// <blockquote>
        /// NeedAppearances is a flag specifying whether to construct appearance
        /// streams and appearance dictionaries for all widget annotations in the
        /// document.
        /// (ISO 32000-1, section 12.7.2 "Interactive Form Dictionary")
        /// </blockquote>
        /// </remarks>
        /// <param name="needAppearances">a boolean. Default value is <c>false</c></param>
        /// <returns>current AcroForm.</returns>
        public virtual iText.Forms.PdfAcroForm SetNeedAppearances(bool needAppearances) {
            if (VersionConforming.ValidatePdfVersionForDeprecatedFeatureLogError(document, PdfVersion.PDF_2_0, VersionConforming
                .DEPRECATED_NEED_APPEARANCES_IN_ACROFORM)) {
                GetPdfObject().Remove(PdfName.NeedAppearances);
                SetModified();
            }
            else {
                Put(PdfName.NeedAppearances, PdfBoolean.ValueOf(needAppearances));
            }
            return this;
        }

        /// <summary>Gets the <c>NeedAppearances</c> boolean property on the AcroForm.</summary>
        /// <remarks>
        /// Gets the <c>NeedAppearances</c> boolean property on the AcroForm.
        /// NeedAppearances has been deprecated in PDF 2.0.
        /// <br />
        /// <blockquote>
        /// NeedAppearances is a flag specifying whether to construct appearance
        /// streams and appearance dictionaries for all widget annotations in the
        /// document.
        /// (ISO 32000-1, section 12.7.2 "Interactive Form Dictionary")
        /// </blockquote>
        /// </remarks>
        /// <returns>
        /// the <c>NeedAppearances</c> property as a
        /// <see cref="iText.Kernel.Pdf.PdfBoolean"/>
        /// . Default value is <c>false</c>
        /// </returns>
        public virtual PdfBoolean GetNeedAppearances() {
            return GetPdfObject().GetAsBoolean(PdfName.NeedAppearances);
        }

        /// <summary>Sets the <c>SigFlags</c> integer property on the AcroForm.</summary>
        /// <remarks>
        /// Sets the <c>SigFlags</c> integer property on the AcroForm.
        /// <br />
        /// <blockquote>
        /// SigFlags is a set of flags specifying various document-level
        /// characteristics related to signature fields.
        /// (ISO 32000-1, section 12.7.2 "Interactive Form Dictionary")
        /// </blockquote>
        /// </remarks>
        /// <param name="sigFlags">
        /// an integer. Use
        /// <see cref="SIGNATURE_EXIST"/>
        /// and/or
        /// <see cref="APPEND_ONLY"/>.
        /// Use bitwise OR operator to combine these values. Default value is <c>0</c>
        /// </param>
        /// <returns>current AcroForm.</returns>
        public virtual iText.Forms.PdfAcroForm SetSignatureFlags(int sigFlags) {
            return Put(PdfName.SigFlags, new PdfNumber(sigFlags));
        }

        /// <summary>Changes the <c>SigFlags</c> integer property on the AcroForm.</summary>
        /// <remarks>
        /// Changes the <c>SigFlags</c> integer property on the AcroForm.
        /// This method allows only to add flags, not to remove them.
        /// <br />
        /// <blockquote>
        /// SigFlags is a set of flags specifying various document-level
        /// characteristics related to signature fields.
        /// (ISO 32000-1, section 12.7.2 "Interactive Form Dictionary")
        /// </blockquote>
        /// </remarks>
        /// <param name="sigFlag">
        /// an integer. Use
        /// <see cref="SIGNATURE_EXIST"/>
        /// and/or
        /// <see cref="APPEND_ONLY"/>.
        /// Use bitwise OR operator to combine these values. Default is <c>0</c>
        /// </param>
        /// <returns>current AcroForm.</returns>
        public virtual iText.Forms.PdfAcroForm SetSignatureFlag(int sigFlag) {
            int flags = GetSignatureFlags();
            flags = flags | sigFlag;
            return SetSignatureFlags(flags);
        }

        /// <summary>Gets the <c>SigFlags</c> integer property on the AcroForm.</summary>
        /// <remarks>
        /// Gets the <c>SigFlags</c> integer property on the AcroForm.
        /// <br />
        /// <blockquote>
        /// SigFlags is a set of flags specifying various document-level
        /// characteristics related to signature fields
        /// (ISO 32000-1, section 12.7.2 "Interactive Form Dictionary")
        /// </blockquote>
        /// </remarks>
        /// <returns>current value for <c>SigFlags</c>.</returns>
        public virtual int GetSignatureFlags() {
            PdfNumber f = GetPdfObject().GetAsNumber(PdfName.SigFlags);
            if (f != null) {
                return f.IntValue();
            }
            else {
                return 0;
            }
        }

        /// <summary>Sets the <c>CO</c> array property on the AcroForm.</summary>
        /// <remarks>
        /// Sets the <c>CO</c> array property on the AcroForm.
        /// <br />
        /// <blockquote>
        /// <c>CO</c>, Calculation Order, is an array of indirect references to
        /// field dictionaries with calculation actions, defining the calculation
        /// order in which their values will be recalculated when the value of any
        /// field changes
        /// (ISO 32000-1, section 12.7.2 "Interactive Form Dictionary")
        /// </blockquote>
        /// </remarks>
        /// <param name="calculationOrder">an array of indirect references</param>
        /// <returns>current AcroForm</returns>
        public virtual iText.Forms.PdfAcroForm SetCalculationOrder(PdfArray calculationOrder) {
            return Put(PdfName.CO, calculationOrder);
        }

        /// <summary>Gets the <c>CO</c> array property on the AcroForm.</summary>
        /// <remarks>
        /// Gets the <c>CO</c> array property on the AcroForm.
        /// <br />
        /// <blockquote>
        /// <c>CO</c>, Calculation Order, is an array of indirect references to
        /// field dictionaries with calculation actions, defining the calculation
        /// order in which their values will be recalculated when the value of any
        /// field changes
        /// (ISO 32000-1, section 12.7.2 "Interactive Form Dictionary")
        /// </blockquote>
        /// </remarks>
        /// <returns>an array of indirect references</returns>
        public virtual PdfArray GetCalculationOrder() {
            return GetPdfObject().GetAsArray(PdfName.CO);
        }

        /// <summary>Sets the <c>DR</c> dictionary property on the AcroForm.</summary>
        /// <remarks>
        /// Sets the <c>DR</c> dictionary property on the AcroForm.
        /// <br />
        /// <blockquote>
        /// <c>DR</c> is a resource dictionary containing default resources
        /// (such as fonts, patterns, or colour spaces) that shall be used by form
        /// field appearance streams. At a minimum, this dictionary shall contain a
        /// Font entry specifying the resource name and font dictionary of the
        /// default font for displaying text.
        /// (ISO 32000-1, section 12.7.2 "Interactive Form Dictionary")
        /// </blockquote>
        /// </remarks>
        /// <param name="defaultResources">a resource dictionary</param>
        /// <returns>current AcroForm</returns>
        public virtual iText.Forms.PdfAcroForm SetDefaultResources(PdfDictionary defaultResources) {
            return Put(PdfName.DR, defaultResources);
        }

        /// <summary>Gets the <c>DR</c> dictionary property on the AcroForm.</summary>
        /// <remarks>
        /// Gets the <c>DR</c> dictionary property on the AcroForm.
        /// <br />
        /// <blockquote>
        /// <c>DR</c> is a resource dictionary containing default resources
        /// (such as fonts, patterns, or colour spaces) that shall be used by form
        /// field appearance streams. At a minimum, this dictionary shall contain a
        /// Font entry specifying the resource name and font dictionary of the
        /// default font for displaying text.
        /// (ISO 32000-1, section 12.7.2 "Interactive Form Dictionary")
        /// </blockquote>
        /// </remarks>
        /// <returns>a resource dictionary</returns>
        public virtual PdfDictionary GetDefaultResources() {
            return GetPdfObject().GetAsDictionary(PdfName.DR);
        }

        /// <summary>Sets the <c>DA</c> String property on the AcroForm.</summary>
        /// <remarks>
        /// Sets the <c>DA</c> String property on the AcroForm.
        /// <br />
        /// This method sets a default (fallback value) for the <c>DA</c>
        /// attribute of variable text
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// s.
        /// </remarks>
        /// <param name="appearance">a String containing a sequence of valid PDF syntax</param>
        /// <returns>current AcroForm</returns>
        public virtual iText.Forms.PdfAcroForm SetDefaultAppearance(String appearance) {
            return Put(PdfName.DA, new PdfString(appearance));
        }

        /// <summary>Gets the <c>DA</c> String property on the AcroForm.</summary>
        /// <remarks>
        /// Gets the <c>DA</c> String property on the AcroForm.
        /// <br />
        /// This method returns the default (fallback value) for the <c>DA</c>
        /// attribute of variable text
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// s.
        /// </remarks>
        /// <returns>the form-wide default appearance, as a <c>String</c></returns>
        public virtual PdfString GetDefaultAppearance() {
            return GetPdfObject().GetAsString(PdfName.DA);
        }

        /// <summary>Sets the <c>Q</c> integer property on the AcroForm.</summary>
        /// <remarks>
        /// Sets the <c>Q</c> integer property on the AcroForm.
        /// <br />
        /// This method sets a default (fallback value) for the <c>Q</c>
        /// attribute of variable text
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// s.
        /// </remarks>
        /// <param name="justification">an integer representing a justification value</param>
        /// <returns>current AcroForm</returns>
        /// <seealso cref="iText.Forms.Fields.PdfFormField.SetJustification(int)"/>
        public virtual iText.Forms.PdfAcroForm SetDefaultJustification(int justification) {
            return Put(PdfName.Q, new PdfNumber(justification));
        }

        /// <summary>Gets the <c>Q</c> integer property on the AcroForm.</summary>
        /// <remarks>
        /// Gets the <c>Q</c> integer property on the AcroForm.
        /// <br />
        /// This method gets the default (fallback value) for the <c>Q</c>
        /// attribute of variable text
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// s.
        /// </remarks>
        /// <returns>an integer representing a justification value</returns>
        /// <seealso cref="iText.Forms.Fields.PdfFormField.GetJustification()"/>
        public virtual PdfNumber GetDefaultJustification() {
            return GetPdfObject().GetAsNumber(PdfName.Q);
        }

        /// <summary>Sets the <c>XFA</c> property on the AcroForm.</summary>
        /// <remarks>
        /// Sets the <c>XFA</c> property on the AcroForm.
        /// <br />
        /// <c>XFA</c> can either be a
        /// <see cref="iText.Kernel.Pdf.PdfStream"/>
        /// or a
        /// <see cref="iText.Kernel.Pdf.PdfArray"/>.
        /// Its contents must be valid XFA.
        /// </remarks>
        /// <param name="xfaResource">a stream containing the XDP</param>
        /// <returns>current AcroForm</returns>
        public virtual iText.Forms.PdfAcroForm SetXFAResource(PdfStream xfaResource) {
            return Put(PdfName.XFA, xfaResource);
        }

        /// <summary>Sets the <c>XFA</c> property on the AcroForm.</summary>
        /// <remarks>
        /// Sets the <c>XFA</c> property on the AcroForm.
        /// <br />
        /// <c>XFA</c> can either be a
        /// <see cref="iText.Kernel.Pdf.PdfStream"/>
        /// or a
        /// <see cref="iText.Kernel.Pdf.PdfArray"/>.
        /// Its contents must be valid XFA.
        /// </remarks>
        /// <param name="xfaResource">
        /// an array of text string and stream pairs representing
        /// the individual packets comprising the XML Data Package. (ISO 32000-1,
        /// section 12.7.2 "Interactive Form Dictionary")
        /// </param>
        /// <returns>current AcroForm</returns>
        public virtual iText.Forms.PdfAcroForm SetXFAResource(PdfArray xfaResource) {
            return Put(PdfName.XFA, xfaResource);
        }

        /// <summary>Gets the <c>XFA</c> property on the AcroForm.</summary>
        /// <returns>
        /// an object representing the entire XDP. It can either be a
        /// <see cref="iText.Kernel.Pdf.PdfStream"/>
        /// or a
        /// <see cref="iText.Kernel.Pdf.PdfArray"/>.
        /// </returns>
        public virtual PdfObject GetXFAResource() {
            return GetPdfObject().Get(PdfName.XFA);
        }

        /// <summary>
        /// Gets a
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// by its name.
        /// </summary>
        /// <param name="fieldName">
        /// the name of the
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// to retrieve
        /// </param>
        /// <returns>
        /// the
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// , or <c>null</c> if it
        /// isn't present
        /// </returns>
        public virtual PdfFormField GetField(String fieldName) {
            return fields.Get(fieldName);
        }

        /// <summary>
        /// Gets the attribute generateAppearance, which tells
        /// <see cref="FlattenFields()"/>
        /// to generate an appearance Stream for all
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// s
        /// that don't have one.
        /// </summary>
        /// <returns>bolean value indicating if the appearances need to be generated</returns>
        public virtual bool IsGenerateAppearance() {
            return generateAppearance;
        }

        /// <summary>
        /// Sets the attribute generateAppearance, which tells
        /// <see cref="FlattenFields()"/>
        /// to generate an appearance Stream for all
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// s
        /// that don't have one.
        /// </summary>
        /// <remarks>
        /// Sets the attribute generateAppearance, which tells
        /// <see cref="FlattenFields()"/>
        /// to generate an appearance Stream for all
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// s
        /// that don't have one.
        /// <para />
        /// Not generating appearances will speed up form flattening but the results
        /// can be unexpected in Acrobat. Don't use it unless your environment is
        /// well controlled. The default is <c>true</c>.
        /// <para />
        /// If generateAppearance is set to <c>true</c>, then
        /// <c>NeedAppearances</c> is set to <c>false</c>. This does not
        /// apply vice versa.
        /// <para />
        /// Note, this method does not change default behaviour of
        /// <see cref="iText.Forms.Fields.PdfFormField.SetValue(System.String)"/>
        /// method.
        /// </remarks>
        /// <param name="generateAppearance">a boolean</param>
        public virtual void SetGenerateAppearance(bool generateAppearance) {
            if (generateAppearance) {
                GetPdfObject().Remove(PdfName.NeedAppearances);
                SetModified();
            }
            this.generateAppearance = generateAppearance;
        }

        /// <summary>
        /// Flattens interactive
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// s in the document.
        /// </summary>
        /// <remarks>
        /// Flattens interactive
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// s in the document. If
        /// no fields have been explicitly included via
        /// <see cref="PartialFormFlattening(System.String)"/>
        /// ,
        /// then all fields are flattened. Otherwise only the included fields are
        /// flattened.
        /// </remarks>
        public virtual void FlattenFields() {
            if (document.IsAppendMode()) {
                throw new PdfException(FormsExceptionMessageConstant.FIELD_FLATTENING_IS_NOT_SUPPORTED_IN_APPEND_MODE);
            }
            ICollection<PdfFormField> fields;
            if (fieldsForFlattening.Count == 0) {
                this.fields.Clear();
                fields = new LinkedHashSet<PdfFormField>(GetFormFields().Values);
            }
            else {
                fields = new LinkedHashSet<PdfFormField>();
                foreach (PdfFormField field in fieldsForFlattening) {
                    fields.AddAll(PrepareFieldsForFlattening(field));
                }
            }
            // In case of appearance resources and page resources are the same object, it would not be possible to add
            // the xObject to the page resources. So in that case we would copy page resources and use the copy for
            // xObject, so that circular reference is avoided.
            // We copy beforehand firstly not to produce a copy every time, and secondly not to copy all the
            // xObjects that have already been added to the page resources.
            IDictionary<int, PdfObject> initialPageResourceClones = new LinkedDictionary<int, PdfObject>();
            for (int i = 1; i <= document.GetNumberOfPages(); i++) {
                PdfObject resources = document.GetPage(i).GetPdfObject().GetAsDictionary(PdfName.Resources);
                initialPageResourceClones.Put(i, resources == null ? null : resources.Clone());
            }
            ICollection<PdfPage> wrappedPages = new LinkedHashSet<PdfPage>();
            PdfPage page;
            foreach (PdfFormField field in fields) {
                PdfDictionary fieldObject = field.GetPdfObject();
                page = GetFieldPage(fieldObject);
                if (page == null) {
                    continue;
                }
                PdfAnnotation annotation = PdfAnnotation.MakeAnnotation(fieldObject);
                TagTreePointer tagPointer = null;
                if (annotation != null && document.IsTagged()) {
                    tagPointer = document.GetTagStructureContext().RemoveAnnotationTag(annotation);
                }
                PdfDictionary appDic = fieldObject.GetAsDictionary(PdfName.AP);
                PdfObject asNormal = null;
                if (appDic != null) {
                    asNormal = appDic.GetAsStream(PdfName.N);
                    if (asNormal == null) {
                        asNormal = appDic.GetAsDictionary(PdfName.N);
                    }
                }
                if (generateAppearance) {
                    if (appDic == null || asNormal == null) {
                        field.RegenerateField();
                        appDic = fieldObject.GetAsDictionary(PdfName.AP);
                    }
                }
                PdfObject normal = appDic != null ? appDic.Get(PdfName.N) : null;
                if (null != normal) {
                    PdfFormXObject xObject = null;
                    if (normal.IsStream()) {
                        xObject = new PdfFormXObject((PdfStream)normal);
                    }
                    else {
                        if (normal.IsDictionary()) {
                            PdfName @as = fieldObject.GetAsName(PdfName.AS);
                            if (((PdfDictionary)normal).GetAsStream(@as) != null) {
                                xObject = new PdfFormXObject(((PdfDictionary)normal).GetAsStream(@as));
                                xObject.MakeIndirect(document);
                            }
                        }
                    }
                    if (xObject != null) {
                        //subtype is required field for FormXObject, but can be omitted in normal appearance.
                        xObject.Put(PdfName.Subtype, PdfName.Form);
                        Rectangle annotBBox = fieldObject.GetAsRectangle(PdfName.Rect);
                        if (page.IsFlushed()) {
                            throw new PdfException(FormsExceptionMessageConstant.PAGE_ALREADY_FLUSHED_USE_ADD_FIELD_APPEARANCE_TO_PAGE_METHOD_BEFORE_PAGE_FLUSHING
                                );
                        }
                        PdfCanvas canvas = new PdfCanvas(page, !wrappedPages.Contains(page));
                        wrappedPages.Add(page);
                        // Here we avoid circular reference which might occur when page resources and the appearance xObject's
                        // resources are the same object
                        PdfObject xObjectResources = xObject.GetPdfObject().Get(PdfName.Resources);
                        PdfObject pageResources = page.GetResources().GetPdfObject();
                        if (xObjectResources != null && xObjectResources == pageResources) {
                            xObject.GetPdfObject().Put(PdfName.Resources, initialPageResourceClones.Get(document.GetPageNumber(page)));
                        }
                        if (tagPointer != null) {
                            tagPointer.SetPageForTagging(page);
                            TagReference tagRef = tagPointer.GetTagReference();
                            canvas.OpenTag(tagRef);
                        }
                        AffineTransform at = CalcFieldAppTransformToAnnotRect(xObject, annotBBox);
                        float[] m = new float[6];
                        at.GetMatrix(m);
                        canvas.AddXObjectWithTransformationMatrix(xObject, m[0], m[1], m[2], m[3], m[4], m[5]);
                        if (tagPointer != null) {
                            canvas.CloseTag();
                        }
                    }
                }
                else {
                    LOGGER.LogWarning(FormsExceptionMessageConstant.N_ENTRY_IS_REQUIRED_FOR_APPEARANCE_DICTIONARY);
                }
                PdfArray fFields = GetFields();
                fFields.Remove(fieldObject);
                if (annotation != null) {
                    page.RemoveAnnotation(annotation);
                }
                PdfDictionary parent = fieldObject.GetAsDictionary(PdfName.Parent);
                if (parent != null) {
                    PdfArray kids = parent.GetAsArray(PdfName.Kids);
                    if (kids != null) {
                        kids.Remove(fieldObject);
                        // TODO DEVSIX-2715 if parent was in it's turn the only child of it's parent, we should remove them recursively
                        if (kids.IsEmpty()) {
                            fFields.Remove(parent);
                        }
                    }
                    else {
                        fFields.Remove(parent);
                    }
                }
            }
            GetPdfObject().Remove(PdfName.NeedAppearances);
            if (fieldsForFlattening.Count == 0) {
                GetFields().Clear();
            }
            if (GetFields().IsEmpty()) {
                document.GetCatalog().Remove(PdfName.AcroForm);
            }
        }

        /// <summary>
        /// Tries to remove the
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// with the specified
        /// name from the document.
        /// </summary>
        /// <param name="fieldName">
        /// the name of the
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// to remove
        /// </param>
        /// <returns>a boolean representing whether or not the removal succeeded.</returns>
        public virtual bool RemoveField(String fieldName) {
            PdfFormField field = GetField(fieldName);
            if (field == null) {
                return false;
            }
            PdfDictionary fieldObject = field.GetPdfObject();
            PdfPage page = GetFieldPage(fieldObject);
            PdfAnnotation annotation = PdfAnnotation.MakeAnnotation(fieldObject);
            if (page != null && annotation != null) {
                page.RemoveAnnotation(annotation);
            }
            PdfDictionary parent = field.GetParent();
            if (parent != null) {
                PdfArray kids = parent.GetAsArray(PdfName.Kids);
                kids.Remove(fieldObject);
                fields.JRemove(fieldName);
                kids.SetModified();
                parent.SetModified();
                return true;
            }
            PdfArray fieldsPdfArray = GetFields();
            if (fieldsPdfArray.Contains(fieldObject)) {
                fieldsPdfArray.Remove(fieldObject);
                this.fields.JRemove(fieldName);
                fieldsPdfArray.SetModified();
                SetModified();
                return true;
            }
            return false;
        }

        /// <summary>
        /// Adds a
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// , identified by name, to the list of fields to be flattened.
        /// </summary>
        /// <remarks>
        /// Adds a
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// , identified by name, to the list of fields to be flattened.
        /// Does not perform a flattening operation in itself.
        /// </remarks>
        /// <param name="fieldName">
        /// the name of the
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// to be flattened
        /// </param>
        public virtual void PartialFormFlattening(String fieldName) {
            PdfFormField field = GetFormFields().Get(fieldName);
            if (field != null) {
                fieldsForFlattening.Add(field);
            }
        }

        /// <summary>
        /// Changes the identifier of a
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>.
        /// </summary>
        /// <param name="oldName">the current name of the field</param>
        /// <param name="newName">the new name of the field. Must not be used currently.</param>
        public virtual void RenameField(String oldName, String newName) {
            IDictionary<String, PdfFormField> fields = GetFormFields();
            if (fields.ContainsKey(newName)) {
                return;
            }
            PdfFormField field = fields.Get(oldName);
            if (field != null) {
                field.SetFieldName(newName);
                fields.JRemove(oldName);
                fields.Put(newName, field);
            }
        }

        /// <summary>
        /// Creates an in-memory copy of a
        /// <see cref="iText.Forms.Fields.PdfFormField"/>.
        /// </summary>
        /// <remarks>
        /// Creates an in-memory copy of a
        /// <see cref="iText.Forms.Fields.PdfFormField"/>
        /// . This new field is
        /// not added to the document.
        /// </remarks>
        /// <param name="name">
        /// the name of the
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// to be copied
        /// </param>
        /// <returns>
        /// a clone of the original
        /// <see cref="iText.Forms.Fields.PdfFormField"/>
        /// </returns>
        public virtual PdfFormField CopyField(String name) {
            PdfFormField oldField = GetField(name);
            if (oldField != null) {
                return new PdfFormField((PdfDictionary)oldField.GetPdfObject().Clone().MakeIndirect(document));
            }
            return null;
        }

        /// <summary>
        /// Replaces the
        /// <see cref="iText.Forms.Fields.PdfFormField"/>
        /// of a certain name with another
        /// <see cref="iText.Forms.Fields.PdfFormField"/>.
        /// </summary>
        /// <param name="name">
        /// the name of the
        /// <see cref="iText.Forms.Fields.PdfFormField">form field</see>
        /// to be replaced
        /// </param>
        /// <param name="field">
        /// the new
        /// <see cref="iText.Forms.Fields.PdfFormField"/>
        /// </param>
        public virtual void ReplaceField(String name, PdfFormField field) {
            RemoveField(name);
            AddField(field);
        }

        /// <summary>Gets all AcroForm fields in the document.</summary>
        /// <returns>
        /// a
        /// <see cref="iText.Kernel.Pdf.PdfArray"/>
        /// of field dictionaries
        /// </returns>
        protected internal virtual PdfArray GetFields() {
            PdfArray fields = GetPdfObject().GetAsArray(PdfName.Fields);
            if (fields == null) {
                LOGGER.LogWarning(iText.IO.Logs.IoLogMessageConstant.NO_FIELDS_IN_ACROFORM);
                fields = new PdfArray();
                GetPdfObject().Put(PdfName.Fields, fields);
            }
            return fields;
        }

        protected override bool IsWrappedObjectMustBeIndirect() {
            return false;
        }

        private IDictionary<String, PdfFormField> IterateFields(PdfArray array, IDictionary<String, PdfFormField> 
            fields) {
            int index = 1;
            foreach (PdfObject field in array) {
                if (field.IsFlushed()) {
                    LOGGER.LogInformation(iText.IO.Logs.IoLogMessageConstant.FORM_FIELD_WAS_FLUSHED);
                    continue;
                }
                PdfFormField formField = PdfFormField.MakeFormField(field, document);
                if (formField == null) {
                    LOGGER.LogWarning(MessageFormatUtil.Format(iText.IO.Logs.IoLogMessageConstant.CANNOT_CREATE_FORMFIELD, field
                        .GetIndirectReference() == null ? field : field.GetIndirectReference()));
                    continue;
                }
                PdfString fieldName = formField.GetFieldName();
                String name;
                if (fieldName == null) {
                    PdfFormField parentField = PdfFormField.MakeFormField(formField.GetParent(), document);
                    while (fieldName == null) {
                        fieldName = parentField.GetFieldName();
                        if (fieldName == null) {
                            parentField = PdfFormField.MakeFormField(parentField.GetParent(), document);
                        }
                    }
                    name = fieldName.ToUnicodeString() + "." + index;
                    index++;
                }
                else {
                    name = fieldName.ToUnicodeString();
                }
                fields.Put(name, formField);
                if (formField.GetKids() != null) {
                    IterateFields(formField.GetKids(), fields);
                }
            }
            return fields;
        }

        private IDictionary<String, PdfFormField> IterateFields(PdfArray array) {
            return IterateFields(array, new LinkedDictionary<String, PdfFormField>());
        }

        private PdfDictionary ProcessKids(PdfArray kids, PdfDictionary parent, PdfPage page) {
            if (kids.Size() == 1) {
                PdfDictionary kidDict = (PdfDictionary)kids.Get(0);
                PdfName type = kidDict.GetAsName(PdfName.Subtype);
                if (type != null && type.Equals(PdfName.Widget)) {
                    if (!kidDict.ContainsKey(PdfName.FT)) {
                        // kid is not merged field with widget
                        MergeWidgetWithParentField(parent, kidDict);
                        DefineWidgetPageAndAddToIt(page, parent, true);
                    }
                    else {
                        DefineWidgetPageAndAddToIt(page, kidDict, true);
                    }
                }
                else {
                    PdfArray otherKids = (kidDict).GetAsArray(PdfName.Kids);
                    if (otherKids != null) {
                        ProcessKids(otherKids, kidDict, page);
                    }
                }
            }
            else {
                for (int i = 0; i < kids.Size(); i++) {
                    PdfObject kid = kids.Get(i);
                    PdfArray otherKids = ((PdfDictionary)kid).GetAsArray(PdfName.Kids);
                    if (otherKids != null) {
                        ProcessKids(otherKids, (PdfDictionary)kid, page);
                    }
                }
            }
            return parent;
        }

        private void MergeWidgetWithParentField(PdfDictionary parent, PdfDictionary widgetDict) {
            parent.Remove(PdfName.Kids);
            widgetDict.Remove(PdfName.Parent);
            parent.MergeDifferent(widgetDict);
        }

        private void DefineWidgetPageAndAddToIt(PdfPage currentPage, PdfDictionary mergedFieldAndWidget, bool warnIfPageFlushed
            ) {
            PdfAnnotation annot = PdfAnnotation.MakeAnnotation(mergedFieldAndWidget);
            PdfDictionary pageDic = annot.GetPageObject();
            if (pageDic != null) {
                if (warnIfPageFlushed && pageDic.IsFlushed()) {
                    throw new PdfException(FormsExceptionMessageConstant.PAGE_ALREADY_FLUSHED_USE_ADD_FIELD_APPEARANCE_TO_PAGE_METHOD_BEFORE_PAGE_FLUSHING
                        );
                }
                PdfDocument doc = pageDic.GetIndirectReference().GetDocument();
                PdfPage widgetPage = doc.GetPage(pageDic);
                AddWidgetAnnotationToPage(widgetPage, annot);
            }
            else {
                AddWidgetAnnotationToPage(currentPage, annot);
            }
        }

        private void AddWidgetAnnotationToPage(PdfPage page, PdfAnnotation annot) {
            if (page.ContainsAnnotation(annot)) {
                return;
            }
            TagTreePointer tagPointer = null;
            bool tagged = page.GetDocument().IsTagged();
            if (tagged) {
                tagPointer = page.GetDocument().GetTagStructureContext().GetAutoTaggingPointer();
                //TODO DEVSIX-4117 PrintField attributes
                tagPointer.AddTag(StandardRoles.FORM);
            }
            page.AddAnnotation(annot);
            if (tagged) {
                tagPointer.MoveToParent();
            }
        }

        /// <summary>Determines whether the AcroForm contains XFA data.</summary>
        /// <returns>a boolean</returns>
        public virtual bool HasXfaForm() {
            return xfaForm != null && xfaForm.IsXfaPresent();
        }

        /// <summary>
        /// Gets the
        /// <see cref="iText.Forms.Xfa.XfaForm"/>
        /// atribute.
        /// </summary>
        /// <returns>the XFA form object</returns>
        public virtual XfaForm GetXfaForm() {
            return xfaForm;
        }

        /// <summary>Removes the XFA stream from the document.</summary>
        public virtual void RemoveXfaForm() {
            if (HasXfaForm()) {
                PdfDictionary root = document.GetCatalog().GetPdfObject();
                PdfDictionary acroform = root.GetAsDictionary(PdfName.AcroForm);
                acroform.Remove(PdfName.XFA);
                xfaForm = null;
            }
        }

        public virtual iText.Forms.PdfAcroForm Put(PdfName key, PdfObject value) {
            GetPdfObject().Put(key, value);
            SetModified();
            return this;
        }

        /// <summary>Releases underlying pdf object and other pdf entities used by wrapper.</summary>
        /// <remarks>
        /// Releases underlying pdf object and other pdf entities used by wrapper.
        /// This method should be called instead of direct call to
        /// <see cref="iText.Kernel.Pdf.PdfObject.Release()"/>
        /// if the wrapper is used.
        /// </remarks>
        public virtual void Release() {
            UnsetForbidRelease();
            GetPdfObject().Release();
            foreach (PdfFormField field in fields.Values) {
                field.Release();
            }
            fields = null;
        }

        public override PdfObjectWrapper<PdfDictionary> SetModified() {
            if (GetPdfObject().GetIndirectReference() != null) {
                base.SetModified();
            }
            else {
                document.GetCatalog().SetModified();
            }
            return this;
        }

        private static PdfDictionary CreateAcroFormDictionaryByFields(PdfArray fields) {
            PdfDictionary dictionary = new PdfDictionary();
            dictionary.Put(PdfName.Fields, fields);
            return dictionary;
        }

        private PdfPage GetFieldPage(PdfDictionary annotDic) {
            PdfDictionary pageDic = annotDic.GetAsDictionary(PdfName.P);
            if (pageDic != null) {
                return document.GetPage(pageDic);
            }
            for (int i = 1; i <= document.GetNumberOfPages(); i++) {
                PdfPage page = document.GetPage(i);
                if (!page.IsFlushed()) {
                    PdfAnnotation annotation = PdfAnnotation.MakeAnnotation(annotDic);
                    if (annotation != null && page.ContainsAnnotation(annotation)) {
                        return page;
                    }
                }
            }
            return null;
        }

        private ICollection<PdfFormField> PrepareFieldsForFlattening(PdfFormField field) {
            ICollection<PdfFormField> preparedFields = new LinkedHashSet<PdfFormField>();
            preparedFields.Add(field);
            PdfArray kids = field.GetKids();
            if (kids != null) {
                foreach (PdfObject kid in kids) {
                    PdfFormField kidField = new PdfFormField((PdfDictionary)kid);
                    preparedFields.Add(kidField);
                    if (kidField.GetKids() != null) {
                        preparedFields.AddAll(PrepareFieldsForFlattening(kidField));
                    }
                }
            }
            return preparedFields;
        }

        private AffineTransform CalcFieldAppTransformToAnnotRect(PdfFormXObject xObject, Rectangle annotBBox) {
            PdfArray bBox = xObject.GetBBox();
            if (bBox.Size() != 4) {
                bBox = new PdfArray(new Rectangle(0, 0));
                xObject.SetBBox(bBox);
            }
            float[] xObjBBox = bBox.ToFloatArray();
            PdfArray xObjMatrix = xObject.GetPdfObject().GetAsArray(PdfName.Matrix);
            Rectangle transformedRect;
            if (xObjMatrix != null && xObjMatrix.Size() == 6) {
                Point[] xObjRectPoints = new Point[] { new Point(xObjBBox[0], xObjBBox[1]), new Point(xObjBBox[0], xObjBBox
                    [3]), new Point(xObjBBox[2], xObjBBox[1]), new Point(xObjBBox[2], xObjBBox[3]) };
                Point[] transformedAppBoxPoints = new Point[xObjRectPoints.Length];
                new AffineTransform(xObjMatrix.ToDoubleArray()).Transform(xObjRectPoints, 0, transformedAppBoxPoints, 0, xObjRectPoints
                    .Length);
                float[] transformedRectArr = new float[] { float.MaxValue, float.MaxValue, -float.MaxValue, -float.MaxValue
                     };
                foreach (Point p in transformedAppBoxPoints) {
                    transformedRectArr[0] = (float)Math.Min(transformedRectArr[0], p.x);
                    transformedRectArr[1] = (float)Math.Min(transformedRectArr[1], p.y);
                    transformedRectArr[2] = (float)Math.Max(transformedRectArr[2], p.x);
                    transformedRectArr[3] = (float)Math.Max(transformedRectArr[3], p.y);
                }
                transformedRect = new Rectangle(transformedRectArr[0], transformedRectArr[1], transformedRectArr[2] - transformedRectArr
                    [0], transformedRectArr[3] - transformedRectArr[1]);
            }
            else {
                transformedRect = new Rectangle(0, 0).SetBbox(xObjBBox[0], xObjBBox[1], xObjBBox[2], xObjBBox[3]);
            }
            AffineTransform at = AffineTransform.GetTranslateInstance(-transformedRect.GetX(), -transformedRect.GetY()
                );
            float scaleX = transformedRect.GetWidth() == 0 ? 1 : annotBBox.GetWidth() / transformedRect.GetWidth();
            float scaleY = transformedRect.GetHeight() == 0 ? 1 : annotBBox.GetHeight() / transformedRect.GetHeight();
            at.PreConcatenate(AffineTransform.GetScaleInstance(scaleX, scaleY));
            at.PreConcatenate(AffineTransform.GetTranslateInstance(annotBBox.GetX(), annotBBox.GetY()));
            return at;
        }
    }
}
